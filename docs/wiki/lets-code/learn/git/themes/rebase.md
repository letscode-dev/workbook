# Перемещение веток (rebase)

### Описание

- `rebase` позволяет взять все коммиты из одной ветки и применить их поверх другой
- Выполняет работу аналогичную cherry-pick, только для цепочки коммитов, перенося ветку на новое место
- Коммит, который не даёт изменений называется пустым. rebase автоматически пропускает этот коммит

### `rebase`

```bash
git rebase master      # rebase
git rebase --continue  # продолжить rebase (вызывается при наличии конфликтов)
git rebase --skip      # пропустить коммит (вызывается при наличии конфликтов)
git rebase --abort     # отменить rebase (возвращает обратно HEAD - не изменит историю коммитов)
```

<v-details title="git rebase --continue">

Флаг `--continue` позволяет продолжить rebase после фикса конфликта и перейти к следующему коммиту

```bash
# Rebase develop в текущую ветку
git rebase develop

# Если есть конфликт, то открывается редактор для фикса
# После фикса добавляются изменения в staged
git add .

# Продолжить Rebase и перейти к следующему коммиту
git rebase --continue

# Откроется редактор, где можно изменить название коммита
# После закрытия редактора Rebase перейдет к следующему коммиту
# Если следующего коммита нет, то Rebase завершится
```

</v-details>

<v-details title="git rebase --skip">

Флаг `--skip` позволяет пропустить коммит из текущей ветки и взять изменения из _develop_

```bash
# Rebase develop в текущую ветку
git rebase develop

# Если есть конфликт, то открывается редактор для фикса
# Пропустить коммит из текущей ветки и перейти к следующему коммиту
git rebase --skip
```

</v-details>

<v-details title="git rebase --abort">

Флаг `--abort` позволяет вернусть состояние текушей ветки до rebase.  
Маркер HEAD, будет перенесен обратно на текущую, а уже добавленные коммиты повиснут в воздухе (на них не будет указывать ни один указатель) и будут вскоре удалены.

```bash
# Rebase develop в текущую ветку
git rebase develop

# Если есть конфликт, то открывается редактор для фикса
# Откатиться в состояние до rebase
git rebase --abort
```

</v-details>

### Интерактивный rebase

### `rebase -i`

```bash
# Интерактивный rebase на другую ветку
git rebase -i master
# Интерактивный rebase внутри ветки (изменить историю последних 3х коммитов)
git rebase -i HEAD~3
```

- В начала rebase запустится окно редактора, где можно указать определенную команду для каждого коммита
- При этом переписывается история коммитов - у каждого коммита будет новый хеш

#### Команды

- `pick` (p) - использовать коммит без изменений (по умолчанию)
- `reword` (r) - использовать текущий коммит с возможностью изменения сообщения коммита
- `drop` (d) - удаление коммита (вместо этого можно удалить строку с коммитом)
- `fixup` (f) - будет объединен с предыдущем коммитом в списке, но без изменения сообщения коммита

---

- `squash` (s) - будет объединен с предыдущем коммитом в списке
- `edit` (e) - отредактировать коммит (когда git дойдёт до коммита, выполнится отстановка и git предложит выполнить действия)
- `exec` (x) - выполнить скрипт для указанного коммита
- `break` (b) - остановиться здесь (продолжить rebase позже с 'git rebase --continue')
- `label` (l) - добавить метку для текущего HEAD с заданным именем
- `reset` (t) - сбросить HEAD до указанной метки
- `merge` (m) - создать merge-commit, используя message исходного merge-commit (или однострочный, если исходный merge-commit не был указан)

### Алгоритм работы

- Задача: загрузить изменения из _master_ в _feature_

<v-two>
<template v-slot:first>

::: tip 0. Подготовка
Создание ветки _feature_ и добавление коммитов в _master_ и _feature_
:::

- _feature_ откалывается от _master_
- В каждую ветку поочередно добавляются коммиты

**Порядок коммитов**

1. `master-0` - master
2. `feature-1` - feature
3. `master-1` - master
4. `feature-2` - feature
5. `master-2` - master

::: tip 1. Rebase
Создание новой ветки _feature'_
:::

- Создается новая временная ветка _feature'_ на основе актуального состояния _master_

::: tip 2. Rebase
Копирование всех коммитов _feature_ поверх текущей вершины _master_ для временной ветки _feature'_
:::

- Работает аналогично cherry-pick: последовательно берутся изменения каждого коммита из _feature_ и применяются к вершине _master_: для каждого из коммитов в _feature_ берётся его дельта и сохраняется во временный файл
- Из каждого временного файла создается новый коммит с тем же автором и описанием, но другим хешем

::: tip 3. Rebase
Перенос HEAD из ветки _feature_ в ветку _feature'_
:::

- После копирования коммитов, ссылка _feature_ переносится на вершину новосозданной ветки _feature'_
- Теперь ветка _feature'_ (копия ветки _feature_) основана на последнем состоянии _master_

</template>
<template v-slot:last>
<img src="../@img/rebase.jpg" style="width: 300px" />
</template>
</v-two>

---

### Задание

::: details Пункты

1. Перейти на ветку **master**
   - `git checkout master`
   - (если вы уже на ветке **master**, то выполнять не нужно)
2. Создать ветку от **master**
   - `git checkout -b feature`, где `feature` - название ветки
   - (команду необходимо выполнять находясь в ветке **master**)
3. Добавить 1 коммит в ветку **feature**
   - Добавить новый файл
   - `git add .`
   - `git commit -m 'Message'`
4. Вернуться на ветку **master**
   - `git checkout master`
5. Добавить 1 коммит в **master**
   - Аналогично как для **feature**
6. Вернуться на ветку **feature**
   - `git checkout feature`
7. Актуализировать ветку **feature** с **master**
   - Необходимо взять последние изменения с **master** и добавить в **feature**
   - `git rebase master`
8. Устранение конфликтов rebase - Конфликты могут возникнуть, если изменения коснулись одинаковых файлов в **master** и **feature** - При этом IDE (VSCode в моём случае) подсветит конфликтные файлы - `git add .` - добавить измеенные файлы в staged - `git rebase --continue` - если несколько коммитов, то преходим к фиксу следующего коммита
   :::
